https://grafana.com/blog/2023/04/19/how-to-troubleshoot-memory-leaks-in-go-with-grafana-pyroscope/



# 如何用Grafana Pyroscope解决Go中的内存泄漏问题  

•2023年4月19日•8分钟  

------

在任何编程语言中，内存泄露都是一个严重的问题，Go也不例外。虽然Go有内存回收机制，但是也容易受到内存泄露的影响，它会导致性能下降、操作系统耗尽内存。

To defend itself, the Linux operating system implements an Out-of-Memory (OOM) killer that identifies and terminates processes that consume too much memory and cause the system to become unresponsive.

为了防止这样的情况发生，Linux操作系统实现了一种保护机制——OOM Killer（Out-of-Memory），这种机制会识别出哪些进程占用内存过多、导致操作系统无响应，并终止相应的进程。

In this blog post, we’ll explore the most common causes of memory leaks in Go and demonstrate how to use [Grafana Pyroscope](https://grafana.com/blog/2023/03/15/pyroscope-grafana-phlare-join-for-oss-continuous-profiling/?pg=blog&plcmt=body-txt), an open source continuous profiling solution, to find and fix these leaks.

在这篇博文中，我们将探讨Go语言中，最常见的内存泄露原因，并演示如何使用 [Grafana Pyroscope](https://grafana.com/blog/2023/03/15/pyroscope-grafana-phlare-join-for-oss-continuous-profiling/?pg=blog&plcmt=body-txt)，一个开源的持续分析解决方案，来发现和修复这些漏洞。

## 传统的可观测信号

一般来说，通过长期监视程序或系统的内存使用情况，可以检测到内存泄露。

[![A Grafana dashboard displays memory leak.](https://grafana.com/media/blog/go-memory-leak-pyroscope/go-memory-leak-pyroscope-1.png)*通过在Grafana Cloud中使用Kubernets监控可以看到内存泄露.*](https://grafana.com/media/blog/go-memory-leak-pyroscope/go-memory-leak-pyroscope-1.png)

如今，由于系统的复杂性，很难确定代码中发生内存泄漏的位置。 然而，这些泄漏可能会导致严重的问题:  

 

1. **会降低性能。** 随着内存泄漏的发生，系统可用内存越来越少，这可能导致程序变慢或崩溃，从而导致性能下降。  
2. **系统不稳定。** 如果内存泄漏足够严重，可能会导致整个系统变得不稳定，导致崩溃或其他系统故障。  
3. **增加成本和资源使用。 **当内存泄漏发生时，系统可能会使用更多的资源来管理内存，这会降低系统资源对其他程序的总体可用性。  

 

由于这些原因，尽快发现并修复它们是很重要的。 

## Go中内存泄漏的常见原因

开发人员经常错误地关闭资源、避免无限制的资源的创建，而造成内存泄露，协程也是资源的一种。从消耗系统资源（如内存、CPU时间）的意义上来说，可以将程序视为一种资源，并且如果管理不当，可能会导致内存泄露。

Go协程是由Go运行时管理的轻量级执行线程，它们可以在Go程序执行期间动态创建和销毁。  

理论上来说，在Go中我们可以创建无数个协程，GO运行时可以创建和管理数百万个协程，而不会产生显著的性能开销。但实际上，系统资源是固定的（如内存、CPU和I/O资源），协程的限制由可用的系统资源决定。

开发人员在使用协程时，经常创建了多个协程而没有正确的管理它们的生命周期。对于未使用的协程，即使不需要它们，也会继续消耗系统资源，这可能会导致内存泄露。

如果一个协程被创建而没有关闭，它可以无限期地继续执行，并在内存中保存对对象的引用，防止它们被[垃圾收集](https://tip.golang.org/doc/gc-guide)。 这可能导致程序的内存使用量随着时间的推移而增长，从而可能导致内存泄漏。  

在希望并行处理单个HTTP请求所完成的工作的情况下，创建多个协程并将工作分派给它们是合理的。 

```go
package main

import (
	"log"
	"net/http"
	"time"

	_ "net/http/pprof"
)

func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		responses := make(chan []byte)
		go longRunningTask(responses)
           // do some other tasks in parallel
	})
	log.Fatal(http.ListenAndServe(":8081", nil))
}

func longRunningTask(responses chan []byte) {
	// fetch data from database
	res := make([]byte, 100000)
	time.Sleep(500 * time.Millisecond)
	responses <- res
}
```

上面的这段简单的代码，在连接到并行数据库的HTT服务器过程中，造成了内存泄露。因为HTTP请求不等待响应channel，所以longRunningTask永远处于阻塞状态，从而泄露了用它创建的协程和资源。  

为了防止这种情况的发生，我们需要正确终止协程。我们可以使用各种技术来完成，比如使用channel来通知什么时候应该退出协程，或是使用`context.Cancel`将取消信号传播到协程，或是使用`sync.WaitGroup`确保所有协程在退出程序之前都已完成。

为了避免无限地创建协程，我还建议使用[工作池](https://gobyexample.com/worker-pools)。 当应用程序处于压力之下时，创建太多的协程可能会导致性能下降，因为Go运行时必须管理它们的生命周期。  

 

Go中另一个常见的协程和资源泄漏的情况是没有正确释放Timer或Ticker。 Go文档[regarding the time.After function](https://pkg.go.dev/time#After)表明了这种可能性:  

> "After等待持续时间结束，然后在返回的通道上发送当前时间。 它相当于NewTimer(d). c。 在计时器触发之前，垃圾收集器不会恢复底层计时器。 如果关注效率，则使用NewTimer并调用Timer。 如果不再需要计时器，则停止 ”  

 

如下所示，我建议您在程序中使用[' timer.NewTimer '](https://pkg.go.dev/time#NewTimer)和[' timer.NewTicker '](https://pkg.go.dev/time#NewTicker)时始终坚持使用它们，以便在请求结束时正确释放资源。 

## 如何用Pyroscope发现和修复内存泄露

连续分析可能是查找内存泄漏的一种有用方法，特别是在内存泄漏发生很长一段时间或发生得太快而无法手动观察的情况下。 持续分析包括定期采样程序的内存和程序协程的使用情况，以识别可能指示内存泄漏的模式和异常。  

通过分析程序和内存配置文件，您可以识别Go应用程序中的内存泄漏。 以下是使用Pyroscope的步骤。  

(注:虽然这篇博文主要关注Go语言，但Pyroscope也支持其他语言的内存分析。) 

### 步骤1:确定内存泄漏的来源  

假设您已经有了合适的监控，第一步是找出使用日志、度量或跟踪的系统的哪个部分有问题。  

这可以通过多种方式表现出来:  

- 应用程序或Kubernetes重新启动日志

- 对应用程序或主机内存使用情况进行告警
- 带有范例痕迹的SLO缺口

一旦您确定了系统的部分和时间，您就可以使用连续分析来确定有问题的功能

### 步骤2:将Pyroscope与您的应用程序集成

要开始分析Go应用程序，你需要在应用程序中包含我们的Go模块: 

```go
go get github.com/pyroscope-io/client/pyroscope
```

然后将以下代码添加到应用程序中: 

```go
package main

import "github.com/pyroscope-io/client/pyroscope"

func main() {
    // These 2 lines are only required if you're using mutex or block profiling
    // Read the explanation below for how to set these rates:
    runtime.SetMutexProfileFraction(5)
    runtime.SetBlockProfileRate(5)

    pyroscope.Start(pyroscope.Config {
        ApplicationName: "simple.golang.app",

        // replace this with the address of pyroscope server
        ServerAddress: "http://pyroscope-server:4040",

        // you can disable logging by setting this to nil
        Logger: pyroscope.StandardLogger,

        // optionally, if authentication is enabled, specify the API key:
        // AuthToken:    os.Getenv("PYROSCOPE_AUTH_TOKEN"),

        // you can provide static tags via a map:
        Tags: map[string] string {
            "hostname": os.Getenv("HOSTNAME")
        },

        ProfileTypes: [] pyroscope.ProfileType {
            // these profile types are enabled by default:
            pyroscope.ProfileCPU,
                pyroscope.ProfileAllocObjects,
                pyroscope.ProfileAllocSpace,
                pyroscope.ProfileInuseObjects,
                pyroscope.ProfileInuseSpace,

                // these profile types are optional:
                pyroscope.ProfileGoroutines,
                pyroscope.ProfileMutexCount,
                pyroscope.ProfileMutexDuration,
                pyroscope.ProfileBlockCount,
                pyroscope.ProfileBlockDuration,
        },
    })

    // your code goes here
}
```

要了解更多信息，请查看[Pyroscope文档](https://pyroscope.io/docs/golang/)。 

### 步骤3:向下获取相关的配置文件  

我建议你先看看自己的日常作息，看看是否有什么值得关注的，然后再进行记忆调查。 

<iframe frameborder="0" width="100%" height="400" src="https://flamegraph.com/share/dee1210a-ddff-11ed-9b0d-d641223b6af4/iframe?colorMode=light&amp;onlyDisplay=flamegraph&amp;showToolbar=true" style="box-sizing: border-box;"></iframe>

在这种情况下，很明显我们的`longRunningTask`是问题所在我们应该看看这个。但在实际生活中，您必须探索并将您在火焰图上看到的内容与您对应用程序的期望联系起来。

有趣的是，火焰图中的gooutine stacktrace实际上显示了函数的当前状态——在我们的示例中，它被阻止发送到channel。这是帮助您理解代码正在做什么的另一条信息。

> 对于内存，配置文件将显示分配了内存的函数及其数量，但它不会显示谁在保留内存。这取决于您来找出代码中错误地保留了内存的位置。

要了解更多关于Go的性能配置文件，我建议您阅读[Julia Evans的这篇很棒的博客文章](https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/)。

### 第四步:通过检测确认和预防

假设您现在已经确定了问题所在，您可能想要立即修复它—但是我建议您首先编写一个测试来展示问题。  

这样就可以避免其他工程师再次犯同样的错误。 既然你确信你确实找到了问题，你就会有一个可靠的反馈循环来证明它实际上已经解决了。  

Go有一个强大的测试框架，您可以使用它来编写基准测试或测试来重现您的场景。  

在[基准](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)期间，您甚至可以使用' -benchmem ' 

```go
go test -bench=. -benchmem
```

如果需要，您还可以使用[runtime.ReadMemStats](https://pkg.go.dev/runtime#ReadMemStats)编写一些自定义逻辑来输出内存分配。  

您还可以使用[goleak](https://github.com/uber-go/goleak)包验证在执行后没有泄漏程序。 

```go
func TestA(t *testing.T) {
	defer goleak.VerifyNone(t)

	// test logic here.
}
```



### 步骤5:修复内存泄漏

既然您可以重现并理解您的问题，那么是时候对修复进行迭代并将其部署以进行测试了。 您可以再次利用连续分析来监视您的更改并确认您的期望。 

## 了解Pyroscopet

最后，在所有这些调查和工作之后，您可以通过分享[Grafana]内存使用下降的截图(https://grafana.com/grafana/?pg=blog&plcmt=body-txt)与您的同事分享您的胜利。  

如果你以前没有尝试过[Pyroscope](http://pyroscope.io/)，这是一个开始的好时机。 现在，Pyroscope团队是Grafana实验室的一部分，我们正在将这个项目与Grafana Phlare合并。 查看我们发布消息的[博客文章](https://grafana.com/blog/2023/03/15/pyroscope-grafana-phlare-join-for-oss-continuous-profiling/?pg=blog&plcmt=body-txt)，以及[在GitHub上关注进展](https://github.com/grafana/pyroscope)。  

想了解更多? [现在注册](https://grafana.com/about/events/grafanacon/2023/?pg=blog&plcmt=button)免费参加GrafanaCon 2023，并直接听取Grafana Pyroscope项目负责人的会议，[持续分析与Grafana Pyroscope:开发人员经验，火焰图，以及更多](https://grafana.com/about/events/grafanacon/2023/session/continuous-profiling-with-grafana-pyroscope/?pg=blog&plcmt=body-txt).) 
